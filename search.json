[{"title":"Java基础","url":"/2021/04/24/Java基础/","content":"## 面向对象的三大特性\n### 封装\n把客观事物封装成抽象的类，并且把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。也 就 是 说抽象数据类型对数据信息以及对数据的操作进行打包，将其变成一个不可分割 的实体，在这个实体内部，我们对数据进行隐藏和保密，只留下一些接口供外部调用。\n<!--more--> \n简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。\n\n封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n\n#### 为什么需要封装\n隐藏一个类中不需要对外提供的实现细节；\n\n**属性的封装**：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的 不合理操作；\n\n**方法的封装**：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用；便于修改，增强代码的可维护性；\n\n如何封装：\n利用权限修饰符来描述方法体或属性。private修饰的属性或方法为该类所特有，在任何其他类中都不能直接访问；default修饰的属性或方法具有包访问特性，同一个包中的其他类可以访问；protected修饰的属性或方法在同一个中的其他类可以访问，同时对于不在同一个包中的子类中也可以访问；public修饰的属性或方法外部类中都可以直接访问。\n\n### 继承\n继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。\n\n在本职上是特殊——一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性 ，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。\n\n继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类）。\n比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。\n\n**如何实现继承**： Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。\n\n**继承的优点**： 继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围——在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。\n\n### 多态\n多态（Polymiorph）可以分为两种：设计时多态、运行时多态\n\n**设计（编译）时多态**：即重载（Overload），是指java允许方法名相同而参数不同（返回值可以相同也可以不同），同一个类中允许存在一个或多个以上的同名函数，只要参数类型或参数个数不同即可。\n\n**运行时多态**：即重写（Override）必须是在继承体系中，子类重写父类方法，JVM运行时根据调用该方法的类型决定调用那个方法\n\n**注意**：重载也能发生在继承体系中，而且被final, private修饰的方法是不能被继承的，也就没有重写和重载的说法，但是static修饰的方法可以被继承，不能被重写（其实子类中的方法可以覆盖父类的方法，但这不是重写的关系），但是可以被重载。另外static修饰的方法不建议通过实例对象去调用，最好是类名.staticMethod()去调用，如果通过实例对象去调用，是看该对象引用的类型去调用对应的static方法。\n\n## 反射\nJAVA 反射机制是在**运行状态**中，对于任意一个类，都能够知道这个类的**所有属性和方法**；对于任意一个对象，都**能够调用**它的任意一个方法和属性；这种**动态获取**的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。\n\n反射多被用在框架中\n\n## 面向接口编程\n\n面向接口编程是面向对象编程体系里的思想之一。\n\n### 什么是接口\n\n- 接口是一组规则的集合，规定了实现了它的类必须实现的规则。\n- 接口一定程度上也是同类事物的抽象表示\n\n### 面向接口编程的好处\n\n上层类调用下层类的时候，通过面向接口编程，下层类仅对上层类暴露功能，而不是依赖具体的某个类，这就是接口依赖，这样才符合开闭原则（对扩展开放，对修改关闭）。如果不利用面向接口编程的思想，那么在对下层进行扩展的时候，除了要实现下层类，还要对上层类的代码进行修改，这样开发效率非常低下，而且代码还十分冗余，上层类与下层类耦合程度非常高。\n","tags":["基础概念"],"categories":["Java基础"]},{"title":"多线程和并发编程","url":"/2021/04/24/多线程和并发编程/","content":"进程和线程：进程是操作系统资源分配和调度的最小单位，而线程是进程的执行单元，负责当前进程中程序的执行。\n\n## 线程\n\n### 创建线程的四种方式：\n\n1. 继承Thread类重写run()方法\n2. 实现Runnable接口重写run()方法\n3. 实现Callable接口重写call()方法，然后通过把实现Runnable接口的类通过值传递给FutureTask<>的实例，再通过把这个FutureTask<>的实例通过值传递给Thread类，最后通过FutureTask<>的实例调用.get()方法就能拿到返回的结果。Callable接口有泛型<>，程序返回的值的类型就是该泛型对应的类。\n4. 通过线程池创建。通过Executor接口里的execute方法开启一个线程。线程池可以做到减少创建线程和销毁所带来的开销以及资源浪费，能够更好的管理线程。\n<!--more--> \ncallable和runnable的区别就是前者会返回值，后者没有。\n\nThread实现了静态代理模式（实现了Runnable，也可以传入一个实现了Runnable接口的对象）\n\n## 锁\n\nsleep不会释放锁（每个对象都有一把锁），sleep可以放大问题的发生性\nwait会释放锁。wait是Object类下的一个方法，可以使调用该方法的线程进入等待阻塞状态，同时如果没有设置超时时间的话，需要调用对象.notify()方法或者.notifyAll()方法，建议使用后者，前者可能会导致死锁。\n\n\n### 重量级锁\n\n通过对每个java对象创建一个Monitor监视器，监视器对应操作系统底层的mutex（互斥量），这个东西由操作系统来维护。所以在用这种锁的话会进行频繁的系统调用，会产生频繁的内核态和用户态切换，线程阻塞造成的线程切换，成本非常高。\n\n### 轻量级锁\n\n自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。\n\n顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。\n\nMark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。\n\n当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。\n\n缺点：<br>\n同自旋锁相似：\n\n如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。\n\n作者：猴子007\n链接：https://www.jianshu.com/p/36eedeb3f912\n\n### 偏向锁\n\n在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。\n\n“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。\n\n偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。\n\n缺点：<br>\n同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。\n\n不过这个副作用已经小的多。\n\n如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。\n\n作者：猴子007\n链接：https://www.jianshu.com/p/36eedeb3f912\n\n### 自旋锁\n\n在程序执行的代码时间短时，使用自旋锁其实非常好，因为自旋的时间其实依赖于程序执行时间（如果每个程序执行时间很久，那么就会导致等待锁的线程自旋时间过久，浪费CPU资源）。如果锁的竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能。\n\n补充：当程序执行时间长，但是竞争不激烈的时候，也可以用自旋锁优化。\n\n### 自适应自旋锁\n\n自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：\n\n如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。\n相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。\n自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。\n\n缺点：<br>\n然而，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。\n\n作者：猴子007\n链接：https://www.jianshu.com/p/36eedeb3f912\n\n\n### 锁升级\n\n在只有一个线程来访问一个共享对象的时候，会使用偏向锁，如果开始有多线程开始竞争锁的时候，但是竞争没那么激烈，就会升级为轻量级锁，最后如果竞争非常激烈，就会升级为重量级锁。\n\n### 锁降级\n\n1. 写锁降级为读锁（其实是先显示释放写锁，再加上读锁），这种适用于对数据比较敏感，需要在对数据进行修改以后，获取到修改后的值。\n2. 除了第一种，其实锁降级没什么太大的意义，因为锁降级发生在GC的时候，GC的时候，对象都即将被回收，没用了，所以说锁降级没什么太大的意义。 由于自旋锁不占用CPU，如果加锁代码执行时间短，线程数量少用自旋锁，如果执行时间长，执行数量多的代码，用系统锁。\n\n### 锁粗化\n\n锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。\n\n### 锁消除\n\n消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时（可以简单理解为当某段代码第一次被执行时进行编译，又称即时编译），通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。比如StringBuffer的append是一个同步方法，但是在add方法种的StringBuffer属于一个局部变量，并不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。\n\n锁消除的依据是逃逸分析的数据支持。<br>\n但是如果\n```java\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n```\n这种情况还是会逃逸出去的\n\n而\n```java\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n```\n就不会逃逸出去\n\n锁消除，前提是Java必须运行在server模式（server模式会比client模式做更多的优化），同时必须开启逃逸分析\n\n#### 逃逸分析\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n- 同步省略，如果发现只能被一个线程访问，就不考虑同步\n- 如果一个对象没有逃逸到方法外部，同时开启了逃逸分析，那么就会其内存分配进行优化，比如将堆分配转换为栈分配，栈上分配其实是利用标量替换完成的（就是把成员变量替换为一个一个标量）。\n\n### synchronized关键字\n\n默认修饰方法时，实际同步监视是this对象，如果使用同步块，可以锁任何对象。\n\n在jdk1.6之前使用的是重量级锁，1.6以后做了优化，利用了锁升级的过程。\n\n一般来说Sychronized和.wait()以及.notifyAll()使用。\n\n### Lock\n\nLock是一个接口，具体实现类有ReentranLock，通过.lock()加锁，通过.unlock()解锁，相对于sychronized，lock加锁的方式更加灵活，自定义程度更高，使用起来也比sychronized复杂。\nlock有以下几种加锁方式：\n1. tryLock()，可以设置一个超时时间，时间一到自动释放锁\n2. lock()，普通的上锁方式\n3. lockInterruptibly()，可以响应中断\n\n一般来说Lock和Contidition.await()以及.signal()或者.signalAll()，Condition对象可以通过lock实例.newCondition()实现，一个lock可以有多个Condition实例对象，通过不同的Condition实例对象，就可以做到更灵活的操作锁。（如果使用.signalAll()实际上和.notifyAll()效果一样)\n\n### 死锁\n\n产生死锁的四个必要条件：\n1. 互斥条件：一个资源每次只能被一个线程使用\n2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。\n4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n###  Volatile关键字\nVolatile为什么不能保证原子性操作：计算机内存模型分为：寄存器，高速缓存，主存三个部分。Volatile只能保证高速缓存内的数据是与主存同步的，并不能保证寄存器里的是同步的。就导致了，如果A取到值被读取进了寄存器并发生了自增，这个时候其他线程不会马上得到这个值，因为在寄存器中修改的值只是一个中间变量，并没有对该值做真正的修改。如果此时A线程进入阻塞状态，同时B执行完了整个流程，对值自增了1并且写入主存中，把么根据缓存一致性原则，所有CPU的缓存值都被修改成最新值，此时A又回来继续执行，就会把寄存器中的值写入高速缓存，再写入主存，这个时候就发生了错误，该变量没有自增2而只是自增了1。\n","tags":["并发","Java锁","JUC"],"categories":["Java多线程"]},{"title":"网易一面","url":"/2021/04/23/网易一面/","content":"\n一面\n2021.04.21\n\n1. String=\"123\"和String = new String(\"123\")的区别\n\n2. 平时一般用到什么样的集合类\n\n3. 谈谈你对ThreadLocal的了解，数据存在哪\n<!--more-->\n4. 谈谈你对ThreadPool的了解\n\n5. 谈谈JVM的内存模型\n\n6. volatile了解吗，怎么保证可见性（这里扯了扯内存模型）\n\n7. Java的锁，锁升级等（扯到sychronized的时候说它是重量级锁。。。丢人了）\n\n8. AIO和NIO的区别，I/O多路复用有哪几种（我就答了个select，忘记epoll了，拉跨）\n\n9. TCP和UDP的区别，TCP的四次挥手，close-wait和time-wait分别属于哪个阶段\n\n10. 谈谈对MySQL的理解（说了数据库引擎，数据结构，聚簇索引，非聚簇索引）\n\n11. MySQL的索引在什么情况下会失效（这里答得还可以，主要有专门准备过）\n\n12. 幻读和可重复读，还有间隙锁（这个是我在讲可重复读下在一定程度上解决幻读聊到的）\n\n13. 做过简单的socket编程吗（没有 😪）\n\n14. 算法：就是排列组合题，用回溯+剪枝就可以，大概做了10分钟不到吧，楼主忘记考虑重复问题了，忘了剪枝，但是面试官好像没时间了，所以就没让我改了\n","tags":["凉经"],"categories":["面经"]},{"title":"MVC与三层架构","url":"/2021/04/23/MVC与三层架构/","content":"\nMVC（Model, View, Controller）是一种设计模式，而三层架构(用户表示层（UI），业务逻辑层（BIL），数据访问层（DAL），最后再加上实体类（Model）)是一种软件架构。可以理解为依照MVC这种设计模式的规范去实现一个三层架构。\n<!--more--> \n","tags":["概念理解"],"categories":["杂项"]},{"title":"阿里一面","url":"/2021/04/23/阿里一面/","content":"## **1. Java基础：** \n\n1. 什么是重载和重写？ \n2. 重写有什么限制？ \n3. equals()和hashcode()？ \n4. 什么场景下要重写equals()？\n<!--more-->  \n5. HashMap的put()和get()？ \n6. 线程有哪几种创建方式？ \n7. 代理了解过吗？ \n8. 动态代理如何实现？\n\n \n\n## **2.MySQL:** \n\n1. 执行一个SQL语句MySQL具体是如何执行的？ \n2. 查询慢如何提升查询速度？ \n3. MySQL的索引是怎么样的？ \n4. 对数据库引擎了解吗？ \n5. 大表优化？ \n\n \n\n## **3.Spring:** \n\n1. 了解Spring的IoC和DI吗？ \n2. DI的几种方式？ \n3. 为什么要IoC？ \n4. Spring如何实现IoC？\n5. Spring的动态代理如何实现？\n","tags":["凉经"],"categories":["面经"]},{"title":"操作系统","url":"/2021/04/23/操作系统/","content":"## Java的线程和操作系统的线程的区别\n\n### Java的线程\n\nJDK1.2以前是在用户空间内实现的线程。\n\n优点：关于线程的调度只是在用户态，所以可以减小操作系统内核态到用户态的开销。\n\n缺点：但由于操作系统并不知道线程的存在，因此当一个进程中的某一个线程进行系统调用时，比如缺页中断而导致线程阻塞，此时操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。还有一个问题是假如进程中一个线程长时间不释放CPU，因为用户空间并没有时钟中断机制，会导致此进程中的其它线程得不到CPU而持续等待。\n\nJDK1.2及以后的线程的概念其实就和操作系统的线程一致了，JVM使用的是操作系统原生的线程模型，通过系统调用，将程序的线程交给了操作系统的内核进行调度\n<!--more--> \n### 操作系统的线程\n\n直接使用操作系统中已经实现的线程，线程的创建、销毁、调度、维护都是通过操作系统的内核实现的，只需要通过系统调用而不需要自己设计线程的调度算法和线程对CPU资源的抢占使用。\n\n## 系统调用\n\n运行在用户态的程序想要进行与系统态级别有关的资源的操作时，就需要通过系统调用的方式向操作系统提出服务的请求，并让操作系统代其完成。\n\n这些系统调用按照功能可以分为：\n- 设备管理：完成设备的请求与释放，设备的启动等功能\n- 文件管理：文件读、写、创建、删除。\n- 进程控制：进程创建、撤销，阻塞和唤醒\n- 进程通信：完成进程之间的消息传递、信号传递\n- 内存管理：完成内存分配、回收，获取作业占用内存大小和地址等功能\n\n## 进程和线程的区别\n\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位。\n\t\n线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\n\n## 线程的五种状态\n\n1. 新建状态（new）：线程对象被创建后，就进入了新建状态\n2. 就绪状态（runnable）：可执行状态，调用.start()就进入就绪状态\n3. 运行状态（running）：线程获取CPU权限进行执行。线程只能从就绪状态进入运行状态\n4. 阻塞状态（blocked）：<br>\n\t(1). 等待阻塞——通过调用线程的wait()状态，让线程等待某工作的完成<br>\n\t(2). 同步阻塞——线程在获取sychronized同步锁失败（被其他线程占用），就会进入阻塞状态<br>\n\t(3). 其他阻塞——通过线程的.sleep()或者.join()或发起I/O请求时就会进入阻塞状态，当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n5. 死亡状态（dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n\n## 进程间通信方式\n\n1. 管道/匿名管道（Pipes）\n2. 有名管道（Names Pipes）\n3. 信号（Signal）\n4. 消息队列（Message Queuing）\n5. 信号量（Semaphores）\n6. 共享内存（Shared Memory）\n7. 套接字（Sockets)\n\n## 线程间的同步方式\n\n1. 互斥量（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限\n2. 信号量（Semphores）：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量\n3. 事件（Events）：Wait/Notify，通过通知的方式保持多线程同步，还可以方便的实现多线程优先级的操作\n\n## 进程的调度算法\n\n1. 先到先服务（FCFS）:\n2. 短作业优先（SJF）:\n3. 时间片轮转：\n4. 多级反馈队列：\n5. 优先级调度：\n\n## 操作系统的I/O模型\n1. BI/O: 同步阻塞型I/O\n2. NI/O: 同步非阻塞I/O<br>\nI/O多路复用：\n  - select\n  - poll\n  - epoll\n3. AI/O\n\n## 计算机底层原理\n\n### 内存模型：\n\n存储器速度排序：寄存器-->L1-->L2-->L3。<br>\n空间大小排序：与上面相反。<br>\n寄存器，L1和L2是每个内核独享的，而L3是共享的。<br>\n\n### CPU为何要有高速缓存\n\n内存和硬盘的发展速度远远不及CPU。利用高速缓存可以解决I/O速度和CPU运算速度之间的不匹配问题。<br>\n在CPU访问存储设备时，无论是存储数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。<br>\n\t时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它还有可能会被再次访问。\n\t空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。\n\n### 用户空间和内核空间\n\n程序可以存在于用户态（在用户空间）和内核态（在内核空间）。线程的创建和管理由内核完成。线程阻塞的时候会从用户态陷入到内核态，在内核中保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。所以线程的上下文切换就会导致用户态和内核态的切换，很影响效率。\n\n\n","tags":["操作系统基础"],"categories":["操作系统"]},{"title":"容器","url":"/2021/04/23/容器/","content":" \n1. HashMap是Map接口的实现类。\n2. 底层使用数组+链表+红黑树实现（当一个链表的长度超过8时就将链表变为红黑数结构）。\n3. HashMap的put()方法会对key做一个哈希运算，获得其哈希值，然后在利用哈希值与表长取余（实际上用了&运算，速度快，&运算只有在表长为2的幂次时才是取余，\n    如果对应的位置值为null，则将其放入，如果存在元素（链表或者红黑数），则向后遍历，如果遍历到null，则插入对应的key和value（如果链表长度超过8，先\n    判断数组长度是否小于64，若小于则扩容，否则将链表转换为红黑树），如果存在对应的key，根据onlyIfAbsent参数选择替换与否。\n4. HashMap的get()方法根据键的哈希值取到对应的node节点，具体流程类似put()，查的到就节点的value，查不到就返回null（返回null不一定是没有对应的key，而\n    可能是因为value本身为null）。\n<!--more--> \n","tags":["Java容器框架"],"categories":["Java基础"]},{"title":"Mysql学习","url":"/2021/04/23/MySQL/","content":"## MySQL基本指令\n<!--more--> \n## MySQL的数据引擎\n\n### MyISAM\n### InnoDB\n\n#### InnoDB日志系统\n\n- undo log\n用于回滚\n\n- redo log\n用于恢复缓冲区的数据\n\n- bin log\n用于恢复磁盘数据或者主从复制\n\n#### MVCC(Multi-version concurrency controll)\n\n多版本并发控制，用来保证事务的隔离级别，方便回滚\n\n\n## 索引\n### 索引类型\n\n#### 主键索引\n表的主键列对应的索引就是主键索引，并且一张表只能有一个主键，主键不能为null，不能重复。在InnoDB中，如果一张表里没有主键，就会寻找是否存在唯一索引作为默认的主键，如果没有唯一索引存在，**就会自动创建一个6Byte的自增主键。**\n\n### 索引优化\n\n#### Explain\n\nExplain的各个字段的含义：\n\n\n- id: 查询的顺序，id越大最先执行，id相等排序靠前先执行\n\n- select_type:\n\t1. simple: 简单查询，查询不包含子查询或UNION\n\t2. primary: 复杂查询中的最外层的查询\n\t3. subquery: 包含在子查询中的查询（不在from字句里）\n\t4. derived: 包含在from字句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表\n\t5. union: 在union中的第二个和随后的select查询\n\t\n- table: 查询的表\n\n- partitions: 分区（一般用不到，都是分库分表）\n\n- type: 这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。依次从最优到最差分别为：system > const > eq_ref > range > index > ALL。一般来说保证达到range级别，最好到ref。\n\n  **NULL**：MySQL能在优化阶段分解查询语句，在执行阶段就不用访问表或者索引。比如在索引中选最小值，可以直接走索引来完成。<br>\n  **const**: 常量查询，一般是直接定位一条数据<br>\n  **system**: 查一张表时，这张表只有一条记录，算时const的一种特例<br>\n  **eq_ref**: 如果有表关联（join连接之类），查询时用的是这个表的primary key或unique key，且最多只会返回一条符合条件的记录，那就是eq_ref。简单的select查询不会出现这种type。<br>\n  **ref**: 相比eq_ref，不使用唯一索引，而是使用普通索引，或者唯一索引的部分前缀（联合索引），索引要和某个值比较，可能会找到多个符合条件的行。<br>\n  **range**: 范围扫描，出现在in(), between >, <, =等操作。<br>\n  **index**: 覆盖索引的概念，就是从非主键索引的叶子节点从头开始扫描到尾。<br>\n  **ALL**: 全表扫描，扫描聚簇索引的所有叶子节点。\n\n- possible_keys:\n\n- key:\n\n- key_len:\n\n- ref:\n\n- rows:\n\n- filtered:\n\n- Extra:\n\n#### 索引优化情况\n\n1. 全值匹配：<br>\n\t联合索引的话尽量让索引的长度越高越好，也就是索引用的越多越好。\n2. 最左前缀法则：\n3. 不要再索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效\n4. 存储引擎不能使用索引中**范围**条件右边的列。比如只走了联合索引前两个索引，没有走第三个索引，因为第三个索引是在这个范围内是无序的，所以走不了索引。\n5. 尽量使用覆盖索引（只访问索引的查询（索引包含查询列）），减少select * 语句\n6. MySQL在使用不等于（！=或者 < 加上 > ）的时候无法使用索引会导致全表（因为结果集太大了）\n7. is null, is not null 一般情况下也无法使用索引\n8. like以通配符开头（'$abc...'）MySQL索引失效会变成全表扫描（通配符开头会破坏有序性，因为比较顺序一般都是根据字段的前几个字符来排序的）\n9. 字符串不加单引号索引失效\n10. 少用or或in，用它查询时，MySQL不一定使用索引，MySQL内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。\n11. 范围查询优化<br>\n\t给年龄添加单值索引。可以把范围拆成几个段。\n##### 模糊查询\n\n模糊查询如果用不了索引，可以使用覆盖索引，这样就能用索引。\n\n#### 索引下推\n\n在索引遍历过程中，虽然可能第一个索引导致后面的索引无序，但是可以对后面的索引进行一个判断，过滤掉不符合条件的记录再回表，这样可以减少回表次数。\n\n#### 排序\n\n分为索引排序和文件排序，文件排序效率低\n\n#### 索引设计原则\n\n1. 代码先行，索引后上\n2. 联合索引尽量覆盖条件\n3. 不要再小基数字段上建立索引\n4. 长字符串可以使用前缀索引\n5. where和order by冲突时优先where\n6. 尽量避免单值索引，多用联合索引\n\n\n### 对于关联索引的优化\n\n关联字段加索引\n\n小表驱动大表\n\n例子：\n\n```\nselect * from A where id in (select id from B)\n```\n\nin: 当B表的数据集小于A表的数据集时，in优于exists\n\n```\nselect * from A where id exists (select 1 from B where B.id = A.id)\n```\n\nexists: 当A表的数据集小于B表，用exists\n\n## 锁\n\n### 悲观锁\n\n### 乐观锁\n\n### 表锁\n\n每次锁一张表，开销比较小，加锁快，不会出现死锁，锁粒度大，发生冲突概率大，并发度低，一般用在整表迁移\n\n### 行锁\n\n每次操作锁一行数据，开销大，加锁慢，会出现死锁，锁粒度最小，发生锁冲突的概率最低，并发程度最高。\n\n### 间隙锁\n\n间隙锁，锁的是两个值之间的间隙，意思是把这个间隙给锁住。一定程度上可以在可重复读的级别下解决幻读的问题。只能在**可重复读**下生效。\n\n### 临键锁\n\n是行锁和间隙锁的组合。\n\n### 无索引行锁会升级为表锁\n\n锁主要是加在索引上，如果对非索引字段更新，行锁可能会变成表锁\n\n### 锁优化建议\n- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁\n- 合理设计索引，尽量缩小锁的范围\n- 尽可能减少检索条件范围，避免间隙锁\n- 尽量控制事务大小，减少锁定资源量和时间长度，设计事务加锁的sql尽量放在事务的最后执行\n- 尽可能低级别事务隔离\n\n## 分库分表\n","tags":["Mysql"],"categories":["数据库"]}]