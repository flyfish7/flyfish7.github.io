[{"title":"Mysql学习","url":"/2021/05/10/MySQL/","content":"## MySQL基本指令\n\n基本指令可以看[MySQL菜鸟教程](https://www.runoob.com/mysql/mysql-tutorial.html)\n\n<!--more--> \n### MyISAM和InnoDB的区别\n\n1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务;\n2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败;\n3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\n4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；\n5. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了\n6. MyISAM表格可以被压缩后进行查询操作\n7. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁\n8. InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有\n\n以上内容转载至https://blog.csdn.net/qq_35642036/article/details/82820178\n\n### InnoDB日志系统\n\n- undo log\n用于回滚\n\n- redo log\n用于恢复缓冲区的数据\n\n- bin log\n用于恢复磁盘数据或者主从复制\n\n### MVCC(Multi-version concurrency controll)\n\n多版本并发控制，用来保证事务的隔离级别，方便回滚\n\n\n## 索引\n### 索引类型\n\n#### 主键索引\n表的主键列对应的索引就是主键索引，并且一张表只能有一个主键，主键不能为null，不能重复。在InnoDB中，如果一张表里没有主键，就会寻找是否存在唯一索引作为默认的主键，如果没有唯一索引存在，**就会自动创建一个6Byte的自增主键。**\n\n### 索引优化\n\n#### Explain\n\nExplain的各个字段的含义：\n\n\n- id: 查询的顺序，id越大最先执行，id相等排序靠前先执行\n\n- select_type:\n\t1. simple: 简单查询，查询不包含子查询或UNION\n\t2. primary: 复杂查询中的最外层的查询\n\t3. subquery: 包含在子查询中的查询（不在from字句里）\n\t4. derived: 包含在from字句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表\n\t5. union: 在union中的第二个和随后的select查询\n\t\n- table: 查询的表\n\n- partitions: 分区（一般用不到，都是分库分表）\n\n- type: 这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。依次从最优到最差分别为：system > const > eq_ref > range > index > ALL。一般来说保证达到range级别，最好到ref。\n\n  **NULL**：MySQL能在优化阶段分解查询语句，在执行阶段就不用访问表或者索引。比如在索引中选最小值，可以直接走索引来完成。<br>\n  **const**: 常量查询，一般是直接定位一条数据<br>\n  **system**: 查一张表时，这张表只有一条记录，算时const的一种特例<br>\n  **eq_ref**: 如果有表关联（join连接之类），查询时用的是这个表的primary key或unique key，且最多只会返回一条符合条件的记录，那就是eq_ref。简单的select查询不会出现这种type。<br>\n  **ref**: 相比eq_ref，不使用唯一索引，而是使用普通索引，或者唯一索引的部分前缀（联合索引），索引要和某个值比较，可能会找到多个符合条件的行。<br>\n  **range**: 范围扫描，出现在in(), between >, <, =等操作。<br>\n  **index**: 覆盖索引的概念，就是从非主键索引的叶子节点从头开始扫描到尾。<br>\n  **ALL**: 全表扫描，扫描聚簇索引的所有叶子节点。\n\n- possible_keys:\n\n- key:\n\n- key_len:\n\n- ref:\n\n- rows:\n\n- filtered:\n\n- Extra:\n\n#### 索引优化情况\n\n1. 全值匹配:\n\t联合索引的话尽量让索引的长度越高越好，也就是索引用的越多越好。\n2. 最左前缀法则：\n3. 不要再索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效\n4. 存储引擎不能使用索引中**范围**条件右边的列。比如只走了联合索引前两个索引，没有走第三个索引，因为第三个索引是在这个范围内是无序的，所以走不了索引。\n5. 尽量使用覆盖索引（只访问索引的查询（索引包含查询列）），减少select * 语句\n6. MySQL在使用不等于（！=或者 < 加上 > ）的时候无法使用索引会导致全表（因为结果集太大了）\n7. is null, is not null 一般情况下也无法使用索引\n8. like以通配符开头（'$abc...'）MySQL索引失效会变成全表扫描（通配符开头会破坏有序性，因为比较顺序一般都是根据字段的前几个字符来排序的）\n9. 字符串不加单引号索引失效\n10. 少用or或in，用它查询时，MySQL不一定使用索引，MySQL内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。\n11. 范围查询优化\n\t给年龄添加单值索引。可以把范围拆成几个段。\n#### 模糊查询\n\n模糊查询如果用不了索引，可以使用覆盖索引，这样就能用索引。\n\n#### 索引下推\n\n在索引遍历过程中，虽然可能第一个索引导致后面的索引无序，但是可以对后面的索引进行一个判断，过滤掉不符合条件的记录再回表，这样可以减少回表次数。\n\n#### 排序\n\n分为索引排序和文件排序，文件排序效率低\n\n#### 索引设计原则\n\n1. 代码先行，索引后上\n2. 联合索引尽量覆盖条件\n3. 不要再小基数字段上建立索引\n4. 长字符串可以使用前缀索引\n5. where和order by冲突时优先where\n6. 尽量避免单值索引，多用联合索引\n\n\n### 对于关联索引的优化\n\n关联字段加索引\n\n小表驱动大表\n\n例子：\n\n```\nselect * from A where id in (select id from B)\n```\n\nin: 当B表的数据集小于A表的数据集时，in优于exists\n\n```\nselect * from A where id exists (select 1 from B where B.id = A.id)\n```\n\nexists: 当A表的数据集小于B表，用exists\n\n## 锁\n\n### 表锁\n\n每次锁一张表，开销比较小，加锁快，不会出现死锁，锁粒度大，发生冲突概率大，并发度低，一般用在整表迁移\n\n### 行锁\n\n每次操作锁一行数据，开销大，加锁慢，会出现死锁，锁粒度最小，发生锁冲突的概率最低，并发程度最高。\n\n### 间隙锁\n\n间隙锁，锁的是两个值之间的间隙，意思是把这个间隙给锁住。一定程度上可以在可重复读的级别下解决幻读的问题。只能在**可重复读**下生效。\n\n### 临键锁\n\n是行锁和间隙锁的组合。\n\n### 无索引行锁会升级为表锁\n\n锁主要是加在索引上，如果对非索引字段更新，行锁可能会变成表锁\n\n### 锁优化建议\n- 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁\n- 合理设计索引，尽量缩小锁的范围\n- 尽可能减少检索条件范围，避免间隙锁\n- 尽量控制事务大小，减少锁定资源量和时间长度，设计事务加锁的sql尽量放在事务的最后执行\n- 尽可能低级别事务隔离\n\n## 分库分表\n\n当一张表的数据量过大的时候，就要考虑分库分表\n\n**分库**：将数据库中的数据分到不同的数据库上，例如对表的水平切分，然后将切分的表放在不同的数据库上\n\n**分表**：对单表数据进行拆分，有垂直拆分，也有水平拆分。垂直拆分就是对表的列进行了拆分，将一些列差分出来作为一个单独的表，而水平拆分是将一张表的数据拆分为多张表（这些表的结构都是一样的）\n\n## 什么时候需要分库分表\n\n- 单表的数据达到千万以上，数据库读写比较缓慢（分表）\n- 数据库中的数据占用的空间越来越大，备份时间越来越长（分库）\n- 应用的并发量太大（分库）\n\n## 分库分表带来的问题\n\n- 分库会带来无法进行联表查询（join），需要自己进行手动的封装，比如从一个表拿到数据以后再去另一张表用这个数据去查询\n- 同一个数据库的表被分到了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足需求\n- 分库以后，数据库的自增主键无法满足主键唯一，需要用到分布式id\n- ......\n","tags":["Mysql"],"categories":["数据库"]},{"title":"数据结构基础","url":"/2021/05/09/数据结构/","content":"\n## 红黑树\n\n1. 每个节点或者是黑色，或者是红色。\n2. 根节点是黑色。\n3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n4. 如果一个节点是红色的，则它的子节点必须是黑色的。\n5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。\n<!--more-->\n**注意:**\n\n- 特性3中的叶子节点，是只为空(NIL或null)的节点。\n- 特性5，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。\n","categories":["数据结构"]},{"title":"操作系统","url":"/2021/05/08/操作系统/","content":"## Java的线程和操作系统的线程的区别\n\n### Java的线程\n\nJDK1.2以前是在用户空间内实现的线程。\n\n优点：关于线程的调度只是在用户态，所以可以减小操作系统内核态到用户态的开销。\n\n缺点：但由于操作系统并不知道线程的存在，因此当一个进程中的某一个线程进行系统调用时，比如缺页中断而导致线程阻塞，此时操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。还有一个问题是假如进程中一个线程长时间不释放CPU，因为用户空间并没有时钟中断机制，会导致此进程中的其它线程得不到CPU而持续等待。\n\nJDK1.2及以后的线程的概念其实就和操作系统的线程一致了，JVM使用的是操作系统原生的线程模型，通过系统调用，将程序的线程交给了操作系统的内核进行调度\n<!--more--> \n### 操作系统的线程\n\n直接使用操作系统中已经实现的线程，线程的创建、销毁、调度、维护都是通过操作系统的内核实现的，只需要通过系统调用而不需要自己设计线程的调度算法和线程对CPU资源的抢占使用。\n\n## 系统调用\n\n运行在用户态的程序想要进行与系统态级别有关的资源的操作时，就需要通过系统调用的方式向操作系统提出服务的请求，并让操作系统代其完成。\n\n这些系统调用按照功能可以分为：\n- 设备管理：完成设备的请求与释放，设备的启动等功能\n- 文件管理：文件读、写、创建、删除。\n- 进程控制：进程创建、撤销，阻塞和唤醒\n- 进程通信：完成进程之间的消息传递、信号传递\n- 内存管理：完成内存分配、回收，获取作业占用内存大小和地址等功能\n\n## 进程和线程的区别\n\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位。\n\t\n线程是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\n\n## 线程的五种状态\n\n1. 新建状态（new）：线程对象被创建后，就进入了新建状态\n2. 就绪状态（runnable）：可执行状态，调用.start()就进入就绪状态\n3. 运行状态（running）：线程获取CPU权限进行执行。线程只能从就绪状态进入运行状态\n4. 阻塞状态（blocked）：<br>\n\t(1). 等待阻塞——通过调用线程的wait()状态，让线程等待某工作的完成<br>\n\t(2). 同步阻塞——线程在获取sychronized同步锁失败（被其他线程占用），就会进入阻塞状态<br>\n\t(3). 其他阻塞——通过线程的.sleep()或者.join()或发起I/O请求时就会进入阻塞状态，当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n5. 死亡状态（dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n\n## 进程间通信方式\n\n1. 管道/匿名管道（Pipes）\n2. 有名管道（Names Pipes）\n3. 信号（Signal）\n4. 消息队列（Message Queuing）\n5. 信号量（Semaphores）\n6. 共享内存（Shared Memory）\n7. 套接字（Sockets)\n\n## 线程间的同步方式\n\n1. 互斥量（Mutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限\n2. 信号量（Semphores）：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量\n3. 事件（Events）：Wait/Notify，通过通知的方式保持多线程同步，还可以方便的实现多线程优先级的操作\n\n## 进程的调度算法\n\n1. 先到先服务（FCFS）:\n2. 短作业优先（SJF）:\n3. 时间片轮转：\n4. 多级反馈队列：\n5. 优先级调度：\n\n## 操作系统的I/O模型\n\n1. BIO：同步阻塞型IO\n2. NIO：同步非阻塞IO\n\n    IO多路复用：\n      - select： 每次调用select会阻塞直到IO发生，并且只能知道IO发生了，并不能确定是哪个通道发生了IO。当调用select时会把所有的fd（文件描述符）交给内核去判断哪个有数据，当内核判断到有数据了以后会返回一个集合rset（结构为bitmap），并且有数据的fd会被标记置位，这个集合用来表示哪一个文件描述符是被启用的，返回以后，在用户态下遍历集合，判断哪个fd有数据了，然后再读数据并处理。\n      \n        缺点： 不仅在用户态需要遍历这个fd集合，在内核中也需要遍历，并且这个过程中还有包含了这个集合从用户空间复制到内核空间带来的开销。并且select支持的fd数量只有1024（32位，64位是2048），数量很小。\n        \n      - poll：基本和select一样，区别是他使用了链表，解决了select支持fd只有1024的问题\n\n      - epoll：epoll没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次，这个事件表里包含两个空间，一个是就绪的列表，一个是等待的列表。这里面要知道三个函数epoll_create、epoll_ctl和epoll_wait。\n        linux提供的epoll相关函数如下：\n        \n        ```C++\n        int epoll_create(int size);\n        int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n        int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n        ```\n        (1). epoll_create 函数创建一个epoll句柄，参数size表明内核要监听的描述符数量。调用成功时返回一个epoll句柄描述符，失败时返回-1。\n        \n        (2). epoll_ctl 函数注册要监听的事件类型。四个参数如下：\n        \n        ```epfd``` 表示epoll句柄\n        ```op``` 表示fd操作类型，有如下3种\n        ```EPOLL_CTL_ADD``` 注册新的fd到epfd中\n        ```EPOLL_CTL_MOD``` 修改已注册的fd的监听事件\n        ```EPOLL_CTL_DEL``` 从epfd中删除一个fd\n        ```fd``` 是要监听的描述符\n        ```event``` 表示要监听的事件\n        \n        (3). epoll_wait 函数等待事件的就绪，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。\n        \n        ```epfd``` 是epoll句柄\n        ```events``` 表示从内核得到的就绪事件集合\n        ```maxevents``` 告诉内核events的大小\n        ```timeout``` 表示等待的超时事件\n        \n        epoll和poll一样没有fd数量的限制，它底层是用红黑树实现的，并且也解决了select每次都要把fd集合复制到内核空间的问题，epoll只需要把对fd关心的事件复制一次到内核空间就行了。并且因为epoll是基于事件的，通过回调每次只会返回就绪的fd，所以不需要像select一样遍历所有fd。\n        \n\n3. AIO：异步非阻塞型IO，基于事件和回调，在应用操作以后直接返回，不会阻塞（在执行IO操作的时候不会阻塞），等到IO操作完成通过回调通知线程做后续的操作。\n\n### 阻塞/非阻塞，同步/异步概念介绍\n\n一个IO操作实际上是被分为两步的，就拿处理网络数据来说。第一步：发起IO请求，第二部实际的IO操作。\n\n阻塞IO和非阻塞IO的区别在于第一步；发起IO请求线程是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO；否则就是非阻塞IO；\n\n同步IO和非同步IO的区别在于第二步；如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用都是同步IO；如果不阻塞，而是由操作系统帮你做完再将结果返回给你，那么就是异步IO。\n\n## 计算机底层原理\n\n### 内存模型：\n\n存储器速度排序：寄存器-->L1-->L2-->L3。<br>\n空间大小排序：与上面相反。<br>\n寄存器，L1和L2是每个内核独享的，而L3是共享的。<br>\n\n### CPU为何要有高速缓存\n\n内存和硬盘的发展速度远远不及CPU。利用高速缓存可以解决I/O速度和CPU运算速度之间的不匹配问题。<br>\n在CPU访问存储设备时，无论是存储数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。<br>\n\t时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它还有可能会被再次访问。\n\t空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。\n\n### 用户空间和内核空间\n\n程序可以存在于用户态（在用户空间）和内核态（在内核空间）。线程的创建和管理由内核完成。线程阻塞的时候会从用户态陷入到内核态，在内核中保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。所以线程的上下文切换就会导致用户态和内核态的切换，很影响效率。\n\n\n","tags":["操作系统基础"],"categories":["操作系统"]},{"title":"容器","url":"/2021/05/08/容器/","content":"\n## HashMap\n\nHashMap是Map接口的实现类。\n\n 1. HashMap的put()方法会对key做一个哈希运算，获得其哈希值，然后在利用哈希值与表长len-1取余（实际上用了&运算，速度快，&运算只有在表长len=2^n时，对len-1才是取余，如果对应的位置值为null，则将其放入，如果存在元素（链表或者红黑数），则向后遍历，如果遍历到null，则插入对应的key和value（如果链表长度超过8，先判断数组长度是否小于64，若小于则扩容，否则将链表转换为红黑树），如果存在对应的key，根据onlyIfAbsent参数选择替换与否。\n 2. HashMap的get()方法根据键的哈希值取到对应的node节点，具体流程类似put()，查的到就节点的value，查不到就返回null（返回null不一定是没有对应的key，而可能是因为value本身null）。 \n<!--more--> \n\n### 各种参数的介绍（jdk1.8版本下的）\n\n```java\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n// 这个就是初始的默认大小16\n\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n// 这个是最大的容量\n\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n// 默认的加载因子，其实也可以理解为扩容因子\n\nstatic final int TREEIFY_THRESHOLD = 8;\n// 转换为红黑树的链表的长度阈值\n\nstatic final int UNTREEIFY_THRESHOLD = 6;\n// 退化为链表的长度阈值\n\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n// 转换为红黑树的数组的最小长度（即如果数组长度小于64，即使链表长度到了8也不会发生红黑树的转换，而是对数组进行扩容）\n```\n\n### 1.8之前的HashMap\n\n底层使用数组+链表实现\n\n### 1.8之后的HashMap\n\n底层使用数组+链表+红黑树实现。\n\n### 为什么1.8加入了红黑树\n\n红黑树的是一种自平衡的二叉查找树，但是他不像AVL树一样要求保证绝对的平衡，它允许局部的不平衡，保证大致平衡。这种树查找效率（O(logn)）比链表高（O(n)）。至于为什么1.8的HashMap不在一开始就使用红黑树，在官方的源码中就已经给出了解释\n\n```java\n* Because TreeNodes are about twice the size of regular nodes, we\n* use them only when bins contain enough nodes to warrant use\n* (see TREEIFY_THRESHOLD). And when they become too small (due to\n* removal or resizing) they are converted back to plain bins.  In\n* usages with well-distributed user hashCodes, tree bins are\n* rarely used.  Ideally, under random hashCodes, the frequency of\n* nodes in bins follows a Poisson distribution\n* (http://en.wikipedia.org/wiki/Poisson_distribution) with a\n* parameter of about 0.5 on average for the default resizing\n* threshold of 0.75, although with a large variance because of\n* resizing granularity. Ignoring variance, the expected\n* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /\n* factorial(k)). The first values are:\n*\n* 0:    0.60653066\n* 1:    0.30326533\n* 2:    0.07581633\n* 3:    0.01263606\n* 4:    0.00157952\n* 5:    0.00015795\n* 6:    0.00001316\n* 7:    0.00000094\n* 8:    0.00000006\n* more: less than 1 in ten million\n```\n这里的意思就是说TreeNodes的大小是普通节点的两倍，所以只有在一个数组中的一个元素中包含足够多的节点才会只用红黑树，并且其实在key具有良好分布的哈希码时候，红黑树很少被使用，具体的概率可以看上方代码后面的说明。可以看到一个链表长度到达8的时候的概率是非常非常低的。但是如果长度超过了8，使用红黑树可以带来的是更优秀的查找效率。\n\n","tags":["Java容器框架"],"categories":["Java基础"]},{"title":"JVM总结","url":"/2021/04/27/JVM总结/","content":"\n## 类加载机制\n\n先放个偷来的图\n\n![avatar](https://z3.ax1x.com/2021/04/27/gpy1ij.png)\n\n### 加载：\n\n1. 找到类的全限定名代表的字节码文件，加载文件的二进制字节流\n2. 将字节流代表的静态存储结构转换为方法区的运行时数据结构\n3. 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口\n<!--more-->\n### 验证：\n\n验证字节码的格式是否正确，主要有以下步骤：\n\n![avatar](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/验证阶段.png)\n\n### 准备\n\n给类的静态变量分配内存，并且赋予默认值（不是等号右边指定的值）\n\n### 解析\n\n将符号引用替换为直接引用，会把一些静态方法（符号引用）替换为指向数据所存内存的指针或句柄等，这就是静态链接，而动态链接是在程序的运行期间完成的将符号引用（比如一些非静态方法）替换为直接引用。\n\n### 初始化\n\n对类的静态变量初始化为自己指定的值，执行静态代码块\n\n**Tips:** 可以使用javap -v *.class来查看字节码文件的详细信息\n\n## 类加载器和双亲委派机制\n\n### 类加载器\nJava主要有以下几种类加载器：\n- 引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar（该类加载器是由C++生成的对象，不是Java生成的）\n- 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录下的JAR类包\n- 应用程序类加载器：负责加载ClassPath路径下的类包，一般就是自己写的类\n- 自定义加载器：负责加载用户自定义路径下的类包\n\n**Tips:**  加载器也是对象，另外这几个加载器不存在继承，虽然关系上说是有父子关系引导类加载器-->扩展类加载器-->应用程序类加载器。\n\n### 双亲委派机制\n\n首先会从应用程序类加载器开始，向上委托，直到引导类加载器，如果引导类加载器能够加载该类，那么就直接加载，不能加载就由子类加载器加载，如果子类都不能加载，就无法加载。\n\n#### 为什么要使用双亲委派机制\n\n- 沙箱安全机制：自己写的核心类不会被加载，这样可以防止核心API库被随意篡改\n- 避免类的重复加载：当父类已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性\n\n### 如何自定义类加载器\n\n只需要继承java.lang.ClassLoader类，重写其findClass方法就行\n\n### 打破双亲委派机制\n\n1. 重写ClassLoader类的loadClass方法\n\n2. 线程上下文加载器\n\n例子：Tomcat打破双亲委派机制。Tomcat对不同的web应用程序都有自己的类加载器WebAppClassLoader（用来加载不同的war包，也就是不同的应用程序），不会向上委托，但是一些公共的类还是通过向上委托加载。\n\n**Q：Tomcat如何实现热加载？**\n\nA：设置一个线程检查文件是否被修改，如果被修改就直接把原加载器至空，重新new一个再加载，旧的类加载器就会被GC。\n\n## JVM内存模型\n\n继续偷张图\n\n![avatar](https://z3.ax1x.com/2021/04/27/gpHam4.png)\n\nJava堆：存放对象\n\n方法区：\n\n\n虚拟机栈：\n\n\nFILO，栈里的元素是栈帧，每一个栈帧就代表一个方法，每一个方法都有其局部变量表、操作数栈、动态链接以及方法出口。\n\n所谓局部变量表就存放着该方法中的一些基本数据类型，包括对象的引用。\n\n操作数栈用来存放中间计算的结果。\n\n动态链接的作用就是将该方法的符号引用转换为在方法区中的对应方法的直接引用。\n\n方法返回地址（方法出口）就是返回至该方法结束后当前被调用的位置，存放的是调用该方法PC寄存器的值，同时如果是正常结束，并有return值的时候会将返回值压入调用者的操作数栈中，并且设置PC寄存器地址。\n\n本地方法栈：\n\n程序计数器：\n\n线程共有：Java堆、方法区\n\n线程私有：虚拟机栈、本地方法栈、程序计数器\n\n### jvisualvm\n\n这个命令可以打开可视化界面查看JVM内存具体情况\n\n## 垃圾收集算法\n\n### 标记-清除算法\n\n首先会标记所有存活的对象，统一回收没有被标记的对象，这种算法比较简单，但是会有两种问题发生：\n\n1. 效率上来说，因为标记对象比较多，效率不高\n2. 空间上来说，使用这种算法以后会在内存空间产生大量的不连续的碎片\n\n### 标记-复制算法\n\n把整块内存对半分，每次只使用其中一半内存，在GC的时候会把存活的对象标记并复制到另一半内存中，然后一次性把原来使用的那一半内存清除。这样每次回收就只是对内存的一半进行回收\n\n### 标记-整理算法\n\n先对存活的对象标记起来，标记完以后让所有存活的对象移动到一端，清理端边界以外的内存空间，避免了内存空间不连续的问题\n\n### 分代收集算法\n\n对不同的年龄代使用不同的垃圾收集算法（新生代，老年代）\n\n## 垃圾收集器\n\n### Serial收集器\n\nSerial（串行）收集器是最基础的垃圾收集器，是一个单线程收集器。在垃圾收集的时候必须STW，直到本次收集结束。在新生代使用标记-复制算法，在老年代使用标记-整理算法。\n\n还有Serial Old收集器指的是Serial收集器的老年代版本，在JDK1.5以前与Parrallel Scavenge收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\n\n### Parrallel Scavenge收集器\n\nParrallel收集器是Serial收集器的多线程版本。除了多了个多线程的特点，其他与Serial差不多，默认收集线程数与CPU核数相同。\n\nParallel Scavenge收集器关注点是**吞吐量（高效率的利用CPU）**。CMS等垃圾收集器的关注点更多的是用户线程的**停顿时间（提高用户体验）**。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。\n\nParallel cavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以 选择把内存管理优化交给虚拟机去完成也是一个不错的选择。 \n\n新生代采用复制算法，老年代采用标记-整理算法。\n\n同样的，Parallel Old收集器是Parallel Scavenge收集器的老年代版本。在注重吞吐量以及 CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集器)。\n\n### ParNew收集器\n\nParNew收集器与Parallel收集器很相似，区别在于它可以配合CMS垃圾收集器使用，新生代标记-复制，老年代标记整理。\n\n### CMS(Concurrent Mark Sweep)收集器\n\nCMS收集器是一种非常注重用户体验的垃圾收集器，以获取最短的STW时间。它第一次实现了让垃圾收集线程与用户线程基本上同时工作。CMS收集器是以标记-清楚算法实现的，整个GC过程分为四步：\n\n- 初始标记：暂停所有其他的线程，几下GC roots直接能引用的对象，速度非常快；\n- 并发标记：并发标记是从GC roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时比较长但是不需要暂停用户线程。但是可能会导致标记过的对象状态发生改变；\n- 重新标记：重新标记是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿之间一般会比初始标记的时间稍长，但远比并发标记时间短，主要用到三色标记里的增量更新算法；\n- 并发清理：开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色且不做任何处理；\n- 并发重置：重置本次GC过程中的标记数据。\n\nCMS收集垃圾的时间会比Parrallel收集器耗时更长，因为过程也更复杂，但是STW时间短。\n\n主要优点：并发收集、停顿低\n\n主要缺点：\n\n- 对CPU资源敏感，会和服务抢资源；\n- 无法处理浮动垃圾；（在并发标记和并发清理阶段产生的垃圾被称为浮动垃圾，只能留到下一次清理）\n- 使用标记-清除算法会导致大量空间碎片产生，但是通过参数- XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理；\n- 执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是\"concurrent mode failure\"，此时会进入stop the world，用serial old垃圾收集器来回收。\n\n大内存推荐CMS。\n\n### 三色标记\n\n- 黑色：代表已经被垃圾收集器访问过，代表此刻以该对象为根，它的所有引用都已经被扫描过了，已经不会再被扫描了；\n- 灰色：代表已经被垃圾收集器访问过，此刻以该对象为根，但是它至少有一个引用没有被扫描到；\n- 白色：代表没有该对象被垃圾收集器访问过，如果在并发标记结束后还是白色，代表是垃圾\n\n可能会出现**多标、漏标**的情况。\n\n对于多标，除了会产生浮动垃圾外，不会影响垃圾回收的正确性，只是要等到下一轮才能被回收\n\n对于漏标，就是会导致被引用的对象当成垃圾删除，必须解决这个问题。有两种方案：增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB）。\n\n增量更新就是当黑色对象指向白色对象的引用关系时，会把这个新插入的引用记录下来，等并发结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。可以简单理解为，此时黑色对象变回灰色对象\n\n原始快照就时当灰色对象要删除白色对象的引用关系时，要将这个要删除的引用记录下来，等并发扫描结束以后，再将这些记录过的引用关系的灰色对象为根，重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色（目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾）。\n\n以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。\n","categories":["JVM"]},{"title":"Java基础","url":"/2021/04/24/Java基础/","content":"## 面向对象的三大特性\n### 封装\n把客观事物封装成抽象的类，并且把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。也 就 是 说抽象数据类型对数据信息以及对数据的操作进行打包，将其变成一个不可分割 的实体，在这个实体内部，我们对数据进行隐藏和保密，只留下一些接口供外部调用。\n<!--more--> \n简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。\n\n封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n\n#### 为什么需要封装\n隐藏一个类中不需要对外提供的实现细节；\n\n**属性的封装**：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的 不合理操作；\n\n**方法的封装**：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用；便于修改，增强代码的可维护性；\n\n如何封装：\n利用权限修饰符来描述方法体或属性。private修饰的属性或方法为该类所特有，在任何其他类中都不能直接访问；default修饰的属性或方法具有包访问特性，同一个包中的其他类可以访问；protected修饰的属性或方法在同一个中的其他类可以访问，同时对于不在同一个包中的子类中也可以访问；public修饰的属性或方法外部类中都可以直接访问。\n\n### 继承\n继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。\n\n在本职上是特殊——一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性 ，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。\n\n继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类）。\n比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。\n\n**如何实现继承**： Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。\n\n**继承的优点**： 继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围——在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。\n\n### 多态\n多态（Polymiorph）可以分为两种：设计时多态、运行时多态\n\n**设计（编译）时多态**：即重载（Overload），是指java允许方法名相同而参数不同（返回值可以相同也可以不同），同一个类中允许存在一个或多个以上的同名函数，只要参数类型或参数个数不同即可。\n\n**运行时多态**：即重写（Override）必须是在继承体系中，子类重写父类方法，JVM运行时根据调用该方法的类型决定调用那个方法\n\n**注意**：重载也能发生在继承体系中，而且被final, private修饰的方法是不能被继承的，也就没有重写和重载的说法，但是static修饰的方法可以被继承，不能被重写（其实子类中的方法可以覆盖父类的方法，但这不是重写的关系），但是可以被重载。另外static修饰的方法不建议通过实例对象去调用，最好是类名.staticMethod()去调用，如果通过实例对象去调用，是看该对象引用的类型去调用对应的static方法。\n\n## 反射\nJAVA 反射机制是在**运行状态**中，对于任意一个类，都能够知道这个类的**所有属性和方法**；对于任意一个对象，都**能够调用**它的任意一个方法和属性；这种**动态获取**的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。\n\n反射多被用在框架中\n\n## 面向接口编程\n\n面向接口编程是面向对象编程体系里的思想之一。\n\n### 什么是接口\n\n- 接口是一组规则的集合，规定了实现了它的类必须实现的规则。\n- 接口一定程度上也是同类事物的抽象表示\n\n### 面向接口编程的好处\n\n上层类调用下层类的时候，通过面向接口编程，下层类仅对上层类暴露功能，而不是依赖具体的某个类，这就是接口依赖，这样才符合开闭原则（对扩展开放，对修改关闭）。如果不利用面向接口编程的思想，那么在对下层进行扩展的时候，除了要实现下层类，还要对上层类的代码进行修改，这样开发效率非常低下，而且代码还十分冗余，上层类与下层类耦合程度非常高。\n","tags":["基础概念"],"categories":["Java基础"]},{"title":"多线程和并发编程","url":"/2021/04/24/多线程和并发编程/","content":"进程和线程：进程是操作系统资源分配和调度的最小单位，而线程是进程的执行单元，负责当前进程中程序的执行。\n\n## 线程\n\n### 创建线程的四种方式：\n\n1. 继承Thread类重写run()方法\n2. 实现Runnable接口重写run()方法\n3. 实现Callable接口重写call()方法，然后通过把实现Runnable接口的类通过值传递给FutureTask<>的实例，再通过把这个FutureTask<>的实例通过值传递给Thread类，最后通过FutureTask<>的实例调用.get()方法就能拿到返回的结果。Callable接口有泛型<>，程序返回的值的类型就是该泛型对应的类。\n4. 通过线程池创建。通过Executor接口里的execute方法开启一个线程。线程池可以做到减少创建线程和销毁所带来的开销以及资源浪费，能够更好的管理线程。\n<!--more--> \ncallable和runnable的区别就是前者会返回值，后者没有。\n\nThread实现了静态代理模式（实现了Runnable，也可以传入一个实现了Runnable接口的对象）\n\n## 锁\n\nsleep不会释放锁（每个对象都有一把锁），sleep可以放大问题的发生性\nwait会释放锁。wait是Object类下的一个方法，可以使调用该方法的线程进入等待阻塞状态，同时如果没有设置超时时间的话，需要调用对象.notify()方法或者.notifyAll()方法，建议使用后者，前者可能会导致死锁。\n\n\n### 重量级锁\n\n通过对每个java对象创建一个Monitor监视器，监视器对应操作系统底层的mutex（互斥量），这个东西由操作系统来维护。所以在用这种锁的话会进行频繁的系统调用，会产生频繁的内核态和用户态切换，线程阻塞造成的线程切换，成本非常高。\n\n### 轻量级锁\n\n自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。\n\n顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。\n\nMark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。\n\n当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。\n\n缺点：<br>\n同自旋锁相似：\n\n如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。\n\n作者：猴子007\n链接：https://www.jianshu.com/p/36eedeb3f912\n\n### 偏向锁\n\n在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。\n\n“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。\n\n偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。\n\n缺点：<br>\n同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。\n\n不过这个副作用已经小的多。\n\n如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。\n\n作者：猴子007\n链接：https://www.jianshu.com/p/36eedeb3f912\n\n### 自旋锁\n\n在程序执行的代码时间短时，使用自旋锁其实非常好，因为自旋的时间其实依赖于程序执行时间（如果每个程序执行时间很久，那么就会导致等待锁的线程自旋时间过久，浪费CPU资源）。如果锁的竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能。\n\n补充：当程序执行时间长，但是竞争不激烈的时候，也可以用自旋锁优化。\n\n### 自适应自旋锁\n\n自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：\n\n如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。\n相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。\n自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。\n\n缺点：<br>\n然而，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。\n\n作者：猴子007\n链接：https://www.jianshu.com/p/36eedeb3f912\n\n\n### 锁升级\n\n在只有一个线程来访问一个共享对象的时候，会使用偏向锁，如果开始有多线程开始竞争锁的时候，但是竞争没那么激烈，就会升级为轻量级锁，最后如果竞争非常激烈，就会升级为重量级锁。\n\n### 锁降级\n\n1. 写锁降级为读锁（其实是先显示释放写锁，再加上读锁），这种适用于对数据比较敏感，需要在对数据进行修改以后，获取到修改后的值。\n2. 除了第一种，其实锁降级没什么太大的意义，因为锁降级发生在GC的时候，GC的时候，对象都即将被回收，没用了，所以说锁降级没什么太大的意义。 由于自旋锁不占用CPU，如果加锁代码执行时间短，线程数量少用自旋锁，如果执行时间长，执行数量多的代码，用系统锁。\n\n### 锁粗化\n\n锁粗化就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。\n\n### 锁消除\n\n消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时（可以简单理解为当某段代码第一次被执行时进行编译，又称即时编译），通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。比如StringBuffer的append是一个同步方法，但是在add方法种的StringBuffer属于一个局部变量，并不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。\n\n锁消除的依据是逃逸分析的数据支持。<br>\n但是如果\n```java\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n```\n这种情况还是会逃逸出去的\n\n而\n```java\npublic static StringBuffer craeteStringBuffer(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n```\n就不会逃逸出去\n\n锁消除，前提是Java必须运行在server模式（server模式会比client模式做更多的优化），同时必须开启逃逸分析\n\n#### 逃逸分析\n\n使用逃逸分析，编译器可以对代码做如下优化：\n\n- 同步省略，如果发现只能被一个线程访问，就不考虑同步\n- 如果一个对象没有逃逸到方法外部，同时开启了逃逸分析，那么就会其内存分配进行优化，比如将堆分配转换为栈分配，栈上分配其实是利用标量替换完成的（就是把成员变量替换为一个一个标量）。\n\n### synchronized关键字\n\n默认修饰方法时，实际同步监视是this对象，如果使用同步块，可以锁任何对象。\n\n在jdk1.6之前使用的是重量级锁，1.6以后做了优化，利用了锁升级的过程。\n\n一般来说Sychronized和.wait()以及.notifyAll()使用。\n\n### Lock\n\nLock是一个接口，具体实现类有ReentranLock，通过.lock()加锁，通过.unlock()解锁，相对于sychronized，lock加锁的方式更加灵活，自定义程度更高，使用起来也比sychronized复杂。\nlock有以下几种加锁方式：\n1. tryLock()，可以设置一个超时时间，时间一到自动释放锁\n2. lock()，普通的上锁方式\n3. lockInterruptibly()，可以响应中断\n\n一般来说Lock和Contidition.await()以及.signal()或者.signalAll()，Condition对象可以通过lock实例.newCondition()实现，一个lock可以有多个Condition实例对象，通过不同的Condition实例对象，就可以做到更灵活的操作锁。（如果使用.signalAll()实际上和.notifyAll()效果一样)\n\n### 死锁\n\n产生死锁的四个必要条件：\n1. 互斥条件：一个资源每次只能被一个线程使用\n2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。\n4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n\n###  Volatile关键字\nVolatile为什么不能保证原子性操作：计算机内存模型分为：寄存器，高速缓存，主存三个部分。Volatile只能保证高速缓存内的数据是与主存同步的，并不能保证寄存器里的是同步的。就导致了，如果A取到值被读取进了寄存器并发生了自增，这个时候其他线程不会马上得到这个值，因为在寄存器中修改的值只是一个中间变量，并没有对该值做真正的修改。如果此时A线程进入阻塞状态，同时B执行完了整个流程，对值自增了1并且写入主存中，把么根据缓存一致性原则，所有CPU的缓存值都被修改成最新值，此时A又回来继续执行，就会把寄存器中的值写入高速缓存，再写入主存，这个时候就发生了错误，该变量没有自增2而只是自增了1。\n","tags":["并发","Java锁","JUC"],"categories":["Java多线程"]},{"title":"网易一面","url":"/2021/04/23/网易一面/","content":"\n一面\n2021.04.21\n\n1. String=\"123\"和String = new String(\"123\")的区别\n\n2. 平时一般用到什么样的集合类\n\n3. 谈谈你对ThreadLocal的了解，数据存在哪\n<!--more-->\n4. 谈谈你对ThreadPool的了解\n\n5. 谈谈JVM的内存模型\n\n6. volatile了解吗，怎么保证可见性（这里扯了扯内存模型）\n\n7. Java的锁，锁升级等（扯到sychronized的时候说它是重量级锁。。。丢人了）\n\n8. AIO和NIO的区别，I/O多路复用有哪几种（我就答了个select，忘记epoll了，拉跨）\n\n9. TCP和UDP的区别，TCP的四次挥手，close-wait和time-wait分别属于哪个阶段\n\n10. 谈谈对MySQL的理解（说了数据库引擎，数据结构，聚簇索引，非聚簇索引）\n\n11. MySQL的索引在什么情况下会失效（这里答得还可以，主要有专门准备过）\n\n12. 幻读和可重复读，还有间隙锁（这个是我在讲可重复读下在一定程度上解决幻读聊到的）\n\n13. 做过简单的socket编程吗（没有 😪）\n\n14. 算法：就是排列组合题，用回溯+剪枝就可以，大概做了10分钟不到吧，楼主忘记考虑重复问题了，忘了剪枝，但是面试官好像没时间了，所以就没让我改了\n","tags":["凉经"],"categories":["面经"]},{"title":"MVC与三层架构","url":"/2021/04/23/MVC与三层架构/","content":"\nMVC（Model, View, Controller）是一种设计模式，而三层架构(用户表示层（UI），业务逻辑层（BIL），数据访问层（DAL），最后再加上实体类（Model）)是一种软件架构。可以理解为依照MVC这种设计模式的规范去实现一个三层架构。\n<!--more--> \n","tags":["概念理解"],"categories":["杂项"]},{"title":"阿里一面","url":"/2021/04/23/阿里一面/","content":"## **1. Java基础：** \n\n1. 什么是重载和重写？ \n2. 重写有什么限制？ \n3. equals()和hashcode()？ \n4. 什么场景下要重写equals()？\n<!--more-->  \n5. HashMap的put()和get()？ \n6. 线程有哪几种创建方式？ \n7. 代理了解过吗？ \n8. 动态代理如何实现？\n\n \n\n## **2.MySQL:** \n\n1. 执行一个SQL语句MySQL具体是如何执行的？ \n2. 查询慢如何提升查询速度？ \n3. MySQL的索引是怎么样的？ \n4. 对数据库引擎了解吗？ \n5. 大表优化？ \n\n \n\n## **3.Spring:** \n\n1. 了解Spring的IoC和DI吗？ \n2. DI的几种方式？ \n3. 为什么要IoC？ \n4. Spring如何实现IoC？\n5. Spring的动态代理如何实现？\n","tags":["凉经"],"categories":["面经"]}]